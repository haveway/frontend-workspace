<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>변수와 자료형</title>
</head>
<body>
    <h1>변수와 자료형</h1>

    <h2>변수 선언 시 var뿐만 아니라 let, const를 이용해서 선언 가능</h2>
    <h3>* var, let, const의 차이점</h3>

    <h4>1) 변수 선언 방법</h4>
    <button onclick="defDeclare();">클릭</button>


    <h2>2) Scope(사용가능범위)</h2>
    <button onclick="defScope();">요건 클릭이야 ~</button>

    <script>
        function defDeclare(){

            // 1) var는 중복선언이 가능하다! / 재할당도 된다!
            var userId = 'user01';
            console.log(userId);

            var userId = 'user02';
            console.log(userId);

            userId = 'user03';
            console.log(userId);

            console.log('--------------------');

            // 2) let은 중복선언 불가능하다 / 재할당은 가능!
            let userPwd = 'pass01';
            console.log(userPwd);
            
            /*
            let userPwd = 'pass02';
            console.log(userPwd);
            */

            userPwd = 'pass03';//재할당 가능
            console.log(userPwd);

            console.log('--------------------');

            // 3) const는 중복선언은 불가능하다 / 재할당 불가능(상수같은개념 == 한번 초기화된 값은 변경 불가)
            const userName = '이승철';
            console.log(userName);

            /*
            const userName = '홍길동';
            */
           /*
            userName = '으하하';
            console.log(userName);
            */

            // var는 자유롭게 변수 선언, 사용할 수 있다는 장점이 있다.
            // 하지만, 중복된 변수가 남발 됨 / 의도치않게 값이 변경되어 있을 수 있음 => 가장 큰 단점
            // => 보완하기위해서 나온게 let, const

            // 권장사항 : let, const위주 사용!!!
        }

        function defScope(){
            // 1) var는 function scope == 변수가 선언된 "함수영역" 내에서 사용 가능
            var name = '이승철';

            console.log(name)

            if(1){
                var age = 20;
            }

            //scopeTest();

            console.log(age);

            for(var i = 0; i< 10; i++){}

            console.log(i);

            console.log('------------------------------------------------');
            // 2) let, const는 block scope == 변수가 선언된 블럭{} 내에서만 사용 가능

            if(1){
                let gender = 'M';
                const hobby = "세금내기";
            }

            //console.log(gender);
            //console.log(hobby);
        }
        function scopeTest(){
            console.log(name);
        }
    </script>


    <h3>* 변수 선언 위치에 따른 전역변수 / 지역변수 </h3>

    <pre>

        &lt;script&gt;
            var 변수명;
            변수명;

            function 함수명(){
                var 변수명;
                변수명;
            }
        &lt;/script&gt;

    </pre>

    <script>
        // 전역변수들
        str = '전역변수';
        var str2 = 'var전역변수';
        str4 = '으하하하ㅏ핳';

        // window.onload = 해당 이 html문서가 다 로딩되고 나서
        window.onload = function(){ // 곧바로 실행할 함수를 지정하는 구문

            var str ='지역변수'; // 전역변수명과 중복
            var str3 = '새로운 지역변수';
            str4 = '내가 누구게?';

            console.log('---- str ----');
            console.log(str); // 지역변수명과 전역변수명이 동일한 변수 호출 시 지역변수 호출
            // 그러면 전역변수에 접근하고자 할 경우?? => window.전역변수명 또는 this.전역변수명
            console.log(this.str);
            console.log(window.str);

            console.log('---- str2 ----');
            console.log(str2);
            console.log(this.str2);
            console.log(window.str2);

            console.log('---- str3 ----');
            console.log(str3);
            console.log(window.str3); //undefined(정의되어 있지 않음)
            console.log(this.str3); //undefined(정의되어 있지 않음)

            console.log('---- str4 ----');
            console.log(str4);
            console.log(this.str4);
            console.log(window.str4); // 전역변수 확정
            // 지역변수 선언 시 var를 생략할 경우 전역변수로 취급할 수 있음!

            console.log(this);
        }

        function test(){
            console.log(str4);
        }

    </script>

    <button onclick="test();">전역변수내놔</button>

    <hr>

    <h3>* 자료형</h3>
    <p>
        변수 선언 시 자료형을 별도로 지정하지 않음(자료형의 개념이 없는건 아님) <br>
        => 변수에 대입되는 값(리터럴)에 따라서 알아서 자료형이 자동으로 결정됨 : 타입추론
    </p>

    <h4>자바스크립트의 자료형</h4>

    <ul>
        <li>string(문자열)</li>
        <li>number(숫자)</li>
        <li>boolean(논리값)</li>
        <li>object(객체)</li>
        <li>function(함수)</li>
        <li>undefined(초기화가 안된 변수)</li>
    </ul>

    <button onclick="typeTest();">자료형 테스트</button>
    <div id="area" style="border:1px solid black"></div>

    <script>

        function typeTest(){
            var name = '홍길동'; // string

            var age = 20; // number

            var flag = true; // boolean

            var hobby = ['산책', '영화', '낮잠']; // array

            var user = {
                name : '이승철',
                age : 34,
                id : 'user01'
            }; //object

            var testFn = function(){
                alert('asfasfd');
            }; //function

            var noVal; // undefined

            // 값 찍어보기
            var divEl = document.getElementById('area');

            divEl.innerHTML = name + '<br>';
            divEl.innerHTML += age + '<br>';
            divEl.innerHTML += flag + '<br>';
            divEl.innerHTML += hobby + '<br>';
            divEl.innerHTML += user + '<br>';
            divEl.innerHTML += testFn + '<br>';
            divEl.innerHTML += noVal + '<br><hr>';

            // 자료형 찍어보기
            // 자료형을 확인할 때 필요한 함수 : typeof(변수명);
            
            divEl.innerHTML += typeof(name) + '<br>';
            divEl.innerHTML += typeof(age) + '<br>';
            divEl.innerHTML += typeof(flag) + '<br>';
            divEl.innerHTML += typeof(hobby) + '<br>'; // 배열은 object~
            divEl.innerHTML += typeof(user) + '<br>';
            divEl.innerHTML += typeof(testFn) + '<br>';
            divEl.innerHTML += typeof(noVal) + '<br><hr>';

            /*
                XXX의 나이는 XX살이며 아이디는 XXX입니다.
            */
           // 객체 내부의 속성에 직접 접근
           // user.name, user.age, user.userId .으로 직접접근

           divEl.innerHTML = user.name + '의 나이는 ' + user.age + '이며 아이디는 ' + user.id + '입니다';



        }






    </script>



<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
</body>
</html>